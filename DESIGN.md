# Design Document

Website designed to allow users to collaborate and edit towards creating a cohesive
database of plugins. Bit like a plugin wiki that exposes an api.

Some initial ideas...

- Store a small lean database to serve to others.
- Api namespace serves database so that other plugins/managers can search or integrate.
- User edittable information via plugin page, updated via js.

- Metrics scraped from specified plugins, updated in a timely fashion.
- Voting system. TBD. May require tracking users via some login.
  - OAuth via github account for easy login of users.
- Do an itial import of vim-awesome existing dump data.
- Discover plugins via some simple date sorts:
  - Newest created plugins (i.e. first commit date)
  - Most recently updated (i.e. last commit date)
  - Most active projects (by some metric of activity).
  - Recently Updated in DB.

### URLs

These all return easily parsed json objects, will be defalted to save size.
Their information will be similar to the tables below.

/api/cats
/api/metrics
/api/plugins
/api/tags
/api/reqs

These are the ones normal users will use/see.
Not sure exactly if I'll go with multiple pages or awesome's uni page approach.

Display information on all plugins by author.
/<author>

Display information on the plugin, including the README/metrics.
/<author>/<name>

Display all plugins with tag name.
/tag/<name>

/cats/<name>

### Overall Database

Database name: awe

As github is currently a core host of github plugins, I will use
the 'author/repo' string as a key to tie the db together. Even if github abandoned
this is a very logical pairing to use.

### Table: plugins

Main plugin table, has quite a few optional fields. Since rethinkdb supports non-uniform
object entries we will only store non-default state.

For each plugin:
    - "desc": Short description summarizing the plugin. Required.
    - "tags": A list of tags that apply to this plugin. Required.
    - "author": Real name to display, i.e. starcraftman -> Jeremy. Optional.
    - "is_fork": Default False. If true, points to parent. Optional
    - "fork": There is an active fork that has replaced the original. Optional.
    - "opts": A dictionary of standard opts to make it work. Optional.
    - "site": The url of the project. Default is: https://github.com/author/repo .
    - "alts": Alternative plugins like this one, substantial overlap in function.

```json
{
  "ctrlpvim/ctrlp.vim": {
    "alts": [
      "kien/ctrlp.vim"
    ],
    "desc": "Fuzzy file, buffer, mru... finder.",
    "tags": [
      "buffers",
      "indexing",
      "mru",
      "tags"
    ]
  },
  "kien/ctrlp.vim": {
    "fork": "ctrlpvim/ctrlp.vim",
    "alts": [
      "ctrlpvim/ctrlp.vim"
    ],
    "desc": "Fuzzy file, buffer, mru... finder.",
    "tags": [
      "buffers",
      "inactive",
      "indexing",
      "mru",
      "tags"
    ]
  },
  "rdnetto/YCM-Generator": {
    "desc": "Generate config files for YouCompleteMe",
    "tags": [
      "c++",
      "make",
      "python"
    ],
    "opts": {
      "branch": "stable"
    }
  },
  "Valloric/YouCompleteMe": {
    "desc": "A code-completion engine for Vim",
    "tags": [
      "c++",
      "code-completion",
      "completion",
      "python"
    ],
    "opts": {
      "do": "./install.py"
    }
  }
}
```

### Table: tags

Table maps tags onto plugin keys. This table will be generated by the server
based on existing tags for each plugin, it is a dictionary inversion.

```json
{
  "buffers": [
    "kien/ctrlp.vim",
    "ctrlpvim/ctrlp.vim"
  ],
  "c++": [
    "rdnetto/YCM-Generator",
    "Valloric/YouCompleteMe"
  ],
  "code-completion": [
    "Valloric/YouCompleteMe"
  ]
}
```


### Table: cats

A table that maps categories onto the tags in that category.
Tag can be in more than 1.
These will have to be agreed upon by consensus.

Example:
```json
{
  "completion": [
    "completion",
    "snippets"
  ],
  "integrations"; [
    "search",
  ]
  "language": [
    "c++",
    "java",
    "python"
  ]
```

### Table: metrics

Table maps some simple metrics that will be scraped/inferred
to determine plugin popularity via some function.
May require borrowing a bit from vim-awesome's scraping.
Alternatively, may use plug-search as a means of doing.

```json
{
  "Valloric/YouCompleteMe": {
    "github_stars": 2000,
    "github_watches": 100,
    "inclusions_vimrc": "Scraped somehow?",
    "update_frequency": "Calculated by looking at commit frequency.",
    "votes": "Tied to some internal voting mechanism."
    "date": {
      "first": "Date of first commit. Required.",
      "last": "Date of first commit. Required.",
      "db_update": "Date of last db update."
  }
}
```

### Table: reqs
Dependence, models dependencies between plugins. Low priority.

    Using the standard debian dependence relations.
    - "depends": Plugin A depends on B if A's core functions would not work without B.
    - "recommends": Part of plugin A's functionality depends on B, the core of A function
    would work without it.
    - "suggests": Plugin A is only tangentially related to B, however, they work together well.
    - "feats": Plugin A depends on feature B if without it, it is useless.

Example:

```json
{
  "Valloric/YouCompleteMe": {
    "suggests": [ "rdnetto/YCM-Generator" ]
    "feats": [ "+python" ]
  }
}
```
